/*
 *    Copyright 2009 Information Control Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.simpliccity.sst.bean.annotation;

import java.lang.annotation.Annotation;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanNameGenerator;
import org.springframework.context.annotation.AnnotationBeanNameGenerator;
import org.springframework.core.type.AnnotationMetadata;

/**
 * <p>A controller that coordinates the use of individual bean name generators
 * for custom annotations during Spring annotation scanning.</p>
 * 
 * <p>Spring only supports the use of a single 
 * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}  
 * to configure the behavior of bean name generation during annotation scanning.  
 * <code>DelegateAnnotationBeanNameGenerator</code> provides a modular approach
 * to name generation that makes it possible to workaround this limitation to 
 * use the information available in individual annotation types to generate 
 * appropriate names.</p>
 * 
 * <p><code>DelegateAnnotationBeanNameGenerator</code> provides the base functionality
 * to coordinate the use of multiple 
 * {@link org.springframework.beans.factory.support.BeanNameGenerator}s.  Concrete
 * subclasses override the {@link #getDelegates()} method to specify the mapping
 * between annotation types recognized by Spring annotation scanning and the 
 * corresponding {@link org.springframework.beans.factory.support.BeanNameGenerator}s.
 * 
 * @author Kevin Fox
 * 
 * @see org.simpliccity.sst.bean.namespace.NamespaceBeanNameGenerator
 *
 */
public abstract class DelegateAnnotationBeanNameGenerator extends AnnotationBeanNameGenerator 
{
	private Log logger = LogFactory.getLog(DelegateAnnotationBeanNameGenerator.class);
	
	/**
	 * <p>Generate a bean name for the given bean definition.</p>
	 * 
	 * <p>This implementation will check to see whether any of the annotations
	 * applied to the class referenced in <code>definition</code> are listed in
	 * the mapping defined by {@link #getDelegates()}.  If so, the name generated
	 * by the corresponding {@link org.springframework.beans.factory.support.BeanNameGenerator}
	 * will be returned.  Otherwise, the name generated by
	 * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}
	 * will be used.</p>
	 * 
	 */
	@Override
	public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)
	{
		String result = null;
		
		// Look for another BeanNameGenerator to delegate to
		BeanNameGenerator delegateGenerator = getDelegateGenerator(definition, getDelegates());
		if (delegateGenerator != null)
		{
			logger.debug("Generating bean name using delegate name generator: " + delegateGenerator.getClass().getName());
			result = delegateGenerator.generateBeanName(definition, registry);
		}
		
		// If name is still null, default to the behavior of AnnotationBeanNameGenerator
		if (result == null)
		{
			logger.debug("Generating bean name using default.");
			result = super.generateBeanName(definition, registry);
		}

		return result;
	}

	/**
	 * Defines the mapping between annotation types and 
	 * {@link org.springframework.beans.factory.support.BeanNameGenerator}s used by
	 * the {@link #generateBeanName(BeanDefinition, BeanDefinitionRegistry)} method.
	 * 
	 * @return Mapping between annotation types and name generators.
	 */
	protected abstract Map<Class<? extends Annotation>, BeanNameGenerator> getDelegates();
	
	private BeanNameGenerator getDelegateGenerator(BeanDefinition definition, Map<Class<? extends Annotation>, BeanNameGenerator> delegates)
	{
		BeanNameGenerator result = null;
		if (definition instanceof AnnotatedBeanDefinition)
		{
			AnnotationMetadata annotationMetadata = ((AnnotatedBeanDefinition) definition).getMetadata();
			
			// Look for an annotation on the bean that matches a known delegate
			for (Entry<Class<? extends Annotation>, BeanNameGenerator> entry : delegates.entrySet())
			{
				if (annotationMetadata.isAnnotated(entry.getKey().getName()))
				{
					result = entry.getValue();
					// Return delegate for first matching annotation
					break;
				}
			}
		}
		
		return result;
	}	
}
